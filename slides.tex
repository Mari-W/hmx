\documentclass[aspectratio=169]{beamer}
\usetheme{Boadilla}
\useoutertheme{infolines}
\setbeamertemplate{navigation symbols}{}

\usepackage{fontspec}
\usepackage{unicode-math}
\usepackage[Latin,Greek]{ucharclasses}
\usepackage{amsmath}
\usepackage{proof}
\usepackage{minted}
\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}
\usepackage[backend=biber]{biblatex}
\addbibresource{references.bib}

\title{HM($X$): Type Inference with Constraint Types $^{\text{\cite{hmx}}}$}
\institute[Uni Freiburg]{Chair of Programming Languages, University of
  Freiburg}
\author{Marius Weidner}

\input{definitions}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Outline}
  \tableofcontents
\end{frame}

\section{HM: Polymorphic Lambda Calculus with Full Type Inference}

\begin{frame}[fragile]
  \frametitle{Hindley Milner Basics}
  \begin{columns}
    \begin{column}{0.38\textwidth}
      \begin{center}
        \begin{itemize}
          \item Let Polymorphism
          \item Full Type Inference
          \item Principle Type Property
                \begin{itemize}
                  \item most general type is inferred
                \end{itemize}
        \end{itemize}
      \end{center}
    \end{column}
    \begin{column}{0.6\textwidth}
      \begin{center}
        \begin{block}{Example: Polymorphic Identity Function}
          \begin{minted}[escapeinside=||, mathescape = true]{ocaml}
let id = |$\symbf Î»$|x. x in    : |$\textcolor{blue}{\symbf{âˆ€Î±. Î± â†’ Î±}}$| 
id 42                : Int
id "Hello World"     : Str
          \end{minted}
        \end{block}
      \end{center}
      \begin{center}
        \begin{block}{Example: Polymorphic List Constructors}
          \begin{minted}[escapeinside=||, mathescape = true]{ocaml}
let nil = ..  : |$\textcolor{blue}{\symbf{âˆ€Î±. Î± â†’}}$| |\textcolor{blue}{\textbf{List}}| |$\textcolor{blue}{\symbf{Î±}}$| 
let cons = .. : |$\textcolor{blue}{\symbf{âˆ€Î±. Î± â†’ Î± â†’}}$| |\textcolor{blue}{\textbf{List}}| |$\textcolor{blue}{\symbf{Î± â†’}}$| |\textcolor{blue}{\textbf{List}}| |$\textcolor{blue}{\symbf{Î±}}$| 
          \end{minted}
        \end{block}
      \end{center}
    \end{column}
  \end{columns}
\end{frame}

\begingroup
\Large
\begin{frame}[fragile]
  \frametitle{Hindley Milner Syntax}
  \begin{columns}
    \begin{column}{0.45\textwidth}
      \begin{align*}
        e \ âˆ·= & \ \ x                    \\
               & | \ Î»x. e                \\
               & | \ e \ e                \\
               & | \ \KWLet x = e \KWIn e
      \end{align*}
    \end{column}
    \begin{column}{0.45\textwidth}
      \begin{center}
        \begin{align*}
          Ï„ \ âˆ·= & \ \ Î±     \\
                 & | \ Ï„ â†’ Ï„
        \end{align*}
      \end{center}
      \begin{center}
        \begin{align*}
          Ïƒ \ âˆ·= & \ \ Ï„     \\
                 & | \ âˆ€Î±. Ïƒ
        \end{align*}
      \end{center}
    \end{column}
  \end{columns}
\end{frame}
\endgroup

\begingroup
\Large
\begin{frame}[fragile]
  \frametitle{Hindley Milner Typing}
  \begin{columns}
    \begin{column}{0.45\textwidth}
      \begin{center}
        \HMLet
      \end{center}
      \begin{center}
        \begin{block}{Example: Instance Relation}
          $âˆ€Î±. Î± â†’ Î± \ \ âŠ‘ \ \ $ Int $â†’$ Int
        \end{block}
      \end{center}
    \end{column}
    \begin{column}{0.45\textwidth}
      \begin{center}
        \HMIntro
      \end{center}
      \begin{center}
        \HMElim
      \end{center}
    \end{column}
  \end{columns}
\end{frame}
\endgroup

\begingroup
\large
\begin{frame}[fragile]
  \frametitle{Outlook: A Program with Constraint Types}
  \begin{center}
    \begin{block}{Example: Record Subtyping Constraints}
      \begin{minted}[escapeinside=||, mathescape = true]{ocaml}
let max = |$\symbf Î»$|r|$â‚$|. |$\symbf Î»$|r|$â‚‚$|.           : |$\textcolor{blue}{\symbf{âˆ€Î±.}}(\textcolor{blue}{\symbf{Î±}} â‰¤$|{key:|\textcolor{blue}{\textbf{Int}}|}|$)\textcolor{blue}{\symbf{âˆ€Î².}}(\textcolor{blue}{\symbf{Î²}} â‰¤$|{key:|\textcolor{blue}{Int}|}|$) \ \textcolor{blue}{\symbf{ â‡’}}$|
  r|$â‚$|.key |$â‰¥$| r|$â‚‚$|.key in           |$\textcolor{blue}{\symbf{Î± â†’ Î² â†’}}$| Bool
max {key = 17, foo = "bar"}   : Bool
    {key = 42, bar = "foo"}
          \end{minted}
    \end{block}
  \end{center}
\end{frame}
\endgroup

\section{Constraint Systems: Formulate Constraints on Types}

\begingroup
\Large
\begin{frame}[fragile]
  \frametitle{Constraint Syntax}
  \begin{align*}
    C \ âˆ·= & \ \ âŠ¥     \\
           & | \ âŠ¤     \\
           & | \ C âˆ§ C \\
           & | \ âˆƒÎ±. C \\
           & | \ Ï„ = Ï„ \\
           & | \ â‹¯
  \end{align*}
\end{frame}
\endgroup

\begin{frame}[fragile]
  \frametitle{Constraint Conditions}
  \begin{columns}
    \begin{column}{0.45\textwidth}
      \begin{block}{Entailment}
        \setlength\abovedisplayskip{0pt}
        \begin{align*}
          C âŠ¢ D & \text{ iff } C \text{ implies } D \\
          C = D & \text{ iff } C âŠ¢ D âˆ§ D âŠ¢ C        \\
          âŠ¢C    & \text{ iff } âŠ¤ âŠ¢ C
        \end{align*}
      \end{block}
      \begin{block}{Existential Quantification}
        \setlength\abovedisplayskip{0pt}
        \begin{align*}
          C             & âŠ¢ âˆƒÎ±. C                      \\
          C âŠ¢ D         & \text{ implies } âˆƒÎ±.C âŠ¢ âˆƒÎ±.D \\
          âˆƒÎ±.(C âˆ§ âˆƒÎ±.D) & = âˆƒÎ±.C âˆ§ âˆƒÎ±.D                \\
          âˆƒÎ±. âˆƒÎ².C      & = âˆƒÎ². âˆƒÎ±.C
        \end{align*}
      \end{block}
    \end{column}
    \begin{column}{0.48\textwidth}
      \begin{block}{Equality}
        \setlength\abovedisplayskip{0pt}
        \begin{align*}
                            & âŠ¢ (Î± = Î±) \\
          (Î± = Î²)           & âŠ¢ (Î² = Î±) \\
          (Î± = Î²) âˆ§ (Î² = Î³) & âŠ¢ (Î± = Î³)
        \end{align*}
      \end{block}
      \begin{block}{Substitution}
        \setlength\abovedisplayskip{0pt}
        \begin{align*}
          (Ï„ = Ï„â€²)                & âŠ¢ (Î¤[Ï„] = Î¤[Ï„â€²])                      \\
          [Ï„/Î±]C = âˆƒÎ±.C âˆ§ (Î± = Ï„) & \text{ for } Î± \text{ not free in } Ï„
        \end{align*}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\begingroup
\large
\begin{frame}[fragile]
  \frametitle{Solved Form}
  \begin{columns}
    \begin{column}{0.6\textwidth}
      \begin{block}{Satisfiability}
        \setlength\abovedisplayskip{0pt}
        \begin{align*}
          sat(C) \text{ iff } âŠ¢ âˆƒ\Vec Î±.C \text{ for } \Vec Î± \text{ free in }
          C
        \end{align*}
      \end{block}
      \begin{block}{Constraints in Solved Form}
        \setlength\abovedisplayskip{0pt}
        \begin{align*}
          C & âˆˆ ğ“¢ \text{ implies } sat(C)                               \\
          C & âˆˆ ğ“¢ \text{ and } C âŠ¢ (Ï„ = Ï„â€²) \text{ implies } âŠ¢ (Ï„ = Ï„â€²) \\
          C & âˆˆ ğ“¢ \text{ implies } âˆƒÎ±.C âˆˆ ğ“¢
        \end{align*}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}
\endgroup

\begingroup
\Large
\section{HM($X$): HM Parametrized over Constraint Systems $X$}
\begin{frame}[fragile]
  \frametitle{HM($X$) Syntax}
  \begin{columns}
    \begin{column}{0.45\textwidth}
      \begin{center}
        \begin{align*}
          e \ âˆ·= & \ x                      \\
                 & | \ Î»x. e                \\
                 & | \ e \ e                \\
                 & | \ \KWLet x = e \KWIn e
        \end{align*}
      \end{center}
    \end{column}
    \begin{column}{0.45\textwidth}
      \begin{center}
        \begin{align*}
          Ï„ \ âˆ·= & \ Î±       \\
                 & | \ Ï„ â†’ Ï„
        \end{align*}
      \end{center}
      \begin{center}
        \begin{align*}
          Ïƒ \ âˆ·= & \ Ï„                                                    \\
                 & | \ \textcolor{blue}{âˆ€\Vec Î±.C â‡’ Ï„} \text{ for } C âˆˆ ğ“¢
        \end{align*}
      \end{center}
    \end{column}
  \end{columns}
\end{frame}
\endgroup

\begin{frame}[fragile]
  \frametitle{HM($X$) Typing}
  \begin{columns}
    \begin{column}{0.45\textwidth}
      \begin{center}
        \HMXLet
      \end{center}
      \begin{center}
        \HMXEq
      \end{center}
    \end{column}
    \begin{column}{0.45\textwidth}
      \begin{center}
        \HMXIntro
      \end{center}
      \begin{center}
        \HMXElim
      \end{center}
    \end{column}
  \end{columns}
\end{frame}

\section{HM($ğ“¡$): Instantiating HM($X$) with Polymorphic Records}

\begingroup
\Large
\section{HM($ğ“¡$) Syntax Extensions}
\begin{frame}[fragile]
  \frametitle{HM($X$) Syntax}
  \begin{columns}
    \begin{column}{0.45\textwidth}
      \begin{center}
        \begin{align*}
          e \ âˆ·= & \ \dots                            \\
                 & | \ \{láµ¢ = eáµ¢\} \text{ for } i âˆˆ â„• \\
                 & | \ e.l
        \end{align*}
      \end{center}
    \end{column}
    \begin{column}{0.45\textwidth}
      \begin{center}
        \begin{align*}
          Ï„ \ âˆ·= & \ \dots                            \\
                 & | \ \{láµ¢ : Ï„áµ¢\} \text{ for } i âˆˆ â„•
        \end{align*}
      \end{center}
    \end{column}
  \end{columns}
  \begin{center}
    \begin{align*}
      c \ âˆ·= & \ \dots            \\
             & | \ Ï„ â‰¤ \{l : Ï„â€²\}
    \end{align*}
  \end{center}
\end{frame}

\endgroup
\begin{frame}[fragile]
  \frametitle{HM($ğ“¡$) Constraint Conditions}
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{block}{Subtyping}
        \setlength\abovedisplayskip{0pt}
        \begin{align*}
          âŠ¢ \{lâ‚ : Ï„â‚, .., lâ‚™ : Ï„â‚™\}           & â‰¤ \{láµ¢ : Ï„áµ¢\} \\
          Ï„ â‰¤ \{l : Ï„â‚\} âˆ§ Ï„ â‰¤ \{l : Ï„â‚‚\}      & âŠ¢ Ï„â‚ = Ï„â‚‚     \\
          \{.., l : Ï„â‚, ..\} â‰¤ \{l : Ï„â‚‚\}      & âŠ¢ Ï„â‚ = Ï„â‚‚     \\
          \{lâ‚ : Ï„â‚, .., lâ‚™ : Ï„â‚™\} â‰¤ \{l : Ï„\} & âŠ¢ âŠ¥
        \end{align*}
      \end{block}
      \begin{block}{Restrict Recusion}
        \setlength\abovedisplayskip{0pt}
        \begin{align*}
          âˆƒÎ±. Î± â‰¤ \{l : Ï„\} & = âŠ¤ \text{ for } Î± \text{ not free in } Ï„ \\
          âˆƒÎ±. Î± â‰¤ \{l : Ï„\} & = âŠ¥ \text{ for } Î± \text{ free in } Ï„
        \end{align*}
      \end{block}
    \end{column}
    \begin{column}{0.4\textwidth}
      \begin{block}{Ordering}
        \setlength\abovedisplayskip{0pt}
        \begin{align*}
          âŠ¢ & \{láµ¢ : Ï„áµ¢\} = \{l_{Ï€(i)} : Ï„_{Ï€(i)}\}   \\
            & \text{ where } Ï€ \text{ is permutation}
        \end{align*}
      \end{block}
      \begin{block}{Solved Form}
        \setlength\abovedisplayskip{0pt}
        \begin{align*}
          Ï„ & â‰¤ \{l : Ï„\} âˆˆ ğ“¢ \text{ implies } Ï„ = Î±             \\
            & \text{ where } Î± â‰¤ \{l : Ï„\} \text{ non-recursive}
        \end{align*}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{HM($ğ“¡$) Advanced Example}
  \begin{columns}
    \begin{column}{0.85\textwidth}
      \begin{center}
        \begin{block}{Example: Nested Record Subtyping Constraints}
          \begin{minted}[escapeinside=||, mathescape = true]{ocaml}
let unwrap = |$\symbf Î»$|r.        : |$\textcolor{blue}{\symbf{âˆ€Î±.âˆƒÎ²}}(\textcolor{blue}{\symbf{Î±}} â‰¤$|{outer:|$\textcolor{blue}{\symbf{Î²}}$|}|$ âˆ§ \textcolor{blue}{\symbf{Î²}} â‰¤$|{inner:|\textcolor{blue}{Int}|}|$) \ \textcolor{blue}{\symbf{ â‡’}}$|
  r.outer.inner in           |$\textcolor{blue}{\symbf{Î± â†’ }}$| Int
unwrap {                : Int
  outer = {
    inner = 42, 
    bar = "foo"
  }, 
  foo = "bar"
} 
          \end{minted}
        \end{block}
      \end{center}
    \end{column}
  \end{columns}
\end{frame}

\section{Meta Theory \& Conclusion: Properties of HM($X$) and beyond HM($X$)}

\begingroup
\large
\begin{frame}[fragile]
  \frametitle{Meta Theoretical Properties \& Outlook}
  \begin{itemize}
    \item Full Type Inference: HM($X$) comes with a type inference algorithm
          that
          \begin{itemize}
            \item solves typing problems by translating them to constraint
                  problems
            \item preserves the \emph{principal type property}, if $X$ fulfills
                  the \emph{principal constraint property}
          \end{itemize}
    \item Type Soundness: HM($X$) is sound, i.e. all valid typing judgements
          \\ \quad $C, Î“ âŠ¢ e : Ïƒ$ where $sound(C)$ imply \\
          \quad $e â†ª eâ€² âˆ¨ val(e)$ (\emph{progress}) and
          $e â†ª eâ€² â†’ C, Î“ âŠ¢ eâ€² : Ïƒ$ (\emph{subject reduction})
          $^{\text{\cite{sts}}}$
    \item SHM($X$): extension with subtyping constraint $Ï„ â‰¤ Ï„â€²$, \\
          \quad small extension to type inference algorithm required
  \end{itemize}
\end{frame}
\endgroup

\begin{frame}[fragile]
  \frametitle{References}
  \nocite{atapl}
  \printbibliography
\end{frame}

\end{document}