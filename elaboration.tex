\documentclass[runningheads]{llncs}

\usepackage{graphicx}
\usepackage{fontspec}
\usepackage{unicode-math}
\usepackage[Latin,Greek]{ucharclasses}
\usepackage{amsmath}
\usepackage{proof}
\usepackage{bigfoot}
\usepackage{minted}
\usepackage{subcaption}
\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}
\usepackage[backend=biber]{biblatex}
\addbibresource{references.bib}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  mathescape
}

\newfontfamily\substitutefont{CMU Serif}
\setTransitionsForGreek{\begingroup\substitutefont}{\endgroup}

% chktex-file 36 
% chktex-file 12

\newcommand{\hmx}{HM($X$)}
\newcommand{\hmr}{HM($\mathcal{R}$)}
\newcommand{\hmo}{HM($\mathcal{O}$)}
\newcommand{\kwlet}{\textbf{let }}
\newcommand{\kwin}{\textbf{ in }}

\title{\includegraphics[width=0.4\textwidth]{logo.png}~\\[1cm] Elaboration on
  \hmx:\\Type Inference with Constraint Types}
\titlerunning{\hmx: Type Inference with Constraint Types}
\institute{Chair of Programming Languages, University of Freiburg \\
  \email{weidner@cs.uni-freiburg.de}}
\author{Marius Weidner}

\begin{document}

\let\oldaddcontentsline\addcontentsline{}
\def\addcontentsline#1#2#3{}
\maketitle
\def\addcontentsline#1#2#3{\oldaddcontentsline{#1}{#2}{#3}}

\begin{abstract}
  We investigate \hmx{} [[CITE]], a family of type systems designed to
  accommodate
  polymorphism, full type inference and constraint types.
  \hmx{} extends the Hindley-Milner type system (HM) [[CITE]], which already
  limits
  System F, to ensure decidability and unambiguity of full type inference.
  The constraint system $X$ utilized in \hmx{} remains abstract, allowing
  instantiating $X$ with arbitrary constraint systems that meet specific
  criteria.
  This abstraction empowers \hmx{} to serve as a model for analyzing various
  constraint-related type features commonly encountered in practice.
  Notable examples include subtyping, substructural
  types and type classes.
  \hmx{} encompasses a sound and complete type inference algorithm that remains
  independent of the actual constraint system
  $X$.
  As a result, the work for proving theoretical properties and designing
  inference algorithms for novel constraint-based type systems within an
  HM context is notably simplified.
\end{abstract}

\setcounter{tocdepth}{2}
\tableofcontents
\newpage

\section{Introduction}

\subsection{Polymorphism and Full Type Inference in HM}
The HM type system represents a well known and understood typing discipline
that
refines System F [[CITE]] by establishing constraints that allow type inference
to be decidable.
HM serves as the foundation for numerous real-world functional programming
languages, including languages like Haskell and Rust.

In System F, we can introduce variables for both expressions and types.
The type $‚àÄŒ±. \ T$, where $Œ±$ binds a new type in $T$,
indicates that an expression of this type is polymorphic over some
arbitrary type $Œ±$.
Unfortunately it is undecidable for arbitrary programs to determine when to
introduce and eliminate $‚àÄ$ types and in consequence type inference in System F
is undecidable [[CITE]].
% Wells, J.B. (1994). "Typability and type checking in the second-order lambda-calculus are equivalent and undecidable". Proceedings of the 9th Annual IEEE Symposium on Logic in Computer Science (LICS). pp. 176‚Äì185. doi:10.1109/LICS.1994.316068. ISBN 0-8186-6310-3. S2CID 15078292.
Thus, System F is equipped with explicit type abstraction ($ŒõŒ±. \ e$)
and type
application ($e \ T$) on the syntax level.

The HM type system imposes several restrictions that make type
inference decidable in a polymorphic context. Moreover, HM ensures that the
most general type (the \emph{principal type}) of a any given program is
inferred.
Consequently, there's no need for extra syntax to introduce or eliminate type
variables.
Instead, HM employs let bindings $\kwlet x = e‚ÇÇ \kwin e‚ÇÅ$ where $e‚ÇÇ$ is the
only expression that is allowed to have a polymorphic type.
Other constructs, such as applications or variables bound by a lambda
abstractions, cannot inherit polymorphic types.
This constraint is commonly referred to as `let polymorphism'.

In the future, we will label polymorphic types as $œÉ$, where a $‚àÄ$-type exists
within $œÉ$, and we will refer to them as `poly types'.
On the contrary, all other types, including base
types, functions, and type variables, will be designated as `mono types' and
denoted as $œÑ$.

Poly types are further constrained to exclusively permit $‚àÄ$ binders at the top
level.
Therefore, a type like $‚àÄŒ±. Œ± ‚Üí ‚àÄŒ±. Œ±$ would not be a valid poly type.
Consequently, we establish that poly types consistently adhere to the structure
$‚àÄ\bar{Œ±}. \ œÑ$, where $\bar{Œ±} = Œ±‚ÇÅ,..,Œ±‚Çô$.
By upholding these two regulations, that is let polymorphism and the exclusion
of
higher-order polymorphism, type inference remains decidable and
yields a principal type.
\begin{example}[Concatination of Lists]
  \begin{lstlisting}
concat : $‚àÄŒ±.$ $[Œ±] ‚Üí [Œ±] ‚Üí [Œ±]$
concat = $Œª$[].      $Œª$ys. ys           
         $Œª$[x:xs]. $Œª$ys. x : (concat xs ys)   
  \end{lstlisting}
\end{example}
Examples assume the extension with various language features such as
lists and pattern matching.
For convenience, type annotations are given for inferred function types.

In this example, HM would be capable of deducing the type $‚àÄŒ±.\ [Œ±] ‚Üí [Œ±] ‚Üí
  [Œ±]$
for the function `concat'.
This type is in fact the most general type for `concat'.

\subsection{Introducing Constraints on Types}
Although parametric polymorphism is already a powerful abstraction, there are
instances where we desire to constrain type variables solely to instantiations
to types that satisfy specific constraints.
We refer to such types as \emph{constraint types}.
Constraints can exhibit various different forms depending on the type features
present in the actual language.
As an illustration, consider HM$_ùì°$, that is HM extended with
polymorphic records [[CITE]].
In this scenario, it becomes valuable to have the capability to specify that a
type variable $Œ±$
should solely be instantiated as a record type containing specific fields.
\begin{example}[Alternative to Selector Syntax on Records for Field `key']
  \begin{lstlisting}
key : $‚àÄŒ±, Œ≤.(Œ± ‚â§ \{$key : $Œ≤\})$ $‚áí Œ± ‚Üí Œ≤$
key = $Œª${key : Œ≤, ..}. key
  \end{lstlisting}
\end{example}
This example simulates the extraction of a particular field from a record,
conventionally
represented as $e.l$ where $l$ denotes a label.
We simulate the extraction of  the field `key'.
Instead of the notation $e.key$, the alternative syntax $key \ e$ could then be
employed.\footnote{
  Simplifying label syntax in this way is a component of a possible translation
  process from HM$_ùì°$ to HM$_ùìû$.

}
We introduce two type variables, namely $Œ±$ and $Œ≤$. While $Œ≤$ exhibits
parametric polymorphism, $Œ±$ functions as a constraint type.
The constraint imposed on $Œ±$, denoted as $Œ± ‚â§ \{$key : $Œ≤\}$, signifies that
$Œ±$ is exclusively permitted to take on a type that corresponds to a record
featuring a `key' field of type $Œ≤$.
For introducing constraint $C$ on type variables $Œ±$, we will adopt the
notation $‚àÄ\bar{Œ±}.C$ $‚áí œÑ$.
Multiple constraints will be combined to a single
constraint using conjunction.

Naturally, we can envision entirely different constraints as well.
Consider a language with overloading and overloading constraints
HM$_ùìû$ [[CITE]].
In HM$_ùìû$, constraints are structured in the form $x : Œ± ‚Üí œÑ$,
wherein an instance for the overloaded identifier $x$ with type $Œ± ‚Üí œÑ$ is
expected to be present.
\begin{example}[Overloading the Equality Operator for Lists]
  \begin{lstlisting}
eq : nat $‚Üí$ nat $‚Üí$ bool
eq = $Œª$0       $Œª$0       = $‚ä§$
     $Œª$suc n. $Œª$suc m. = eq n m 
     $Œª$_.      $Œª$_.      = $‚ä•$
eq : $‚àÄŒ±.($eq $:$ $Œ± ‚Üí Œ± ‚Üí$ bool$)$ $‚áí [Œ±] ‚Üí [Œ±] ‚Üí$ bool
eq = $Œª$[].      $Œª$[].      = $‚ä§$
     $Œª$[x:xs]. $Œª$[y:ys]. = eq x y $‚àß$ eq xs ys
     $Œª$_.       $Œª$_.       = $‚ä•$
  \end{lstlisting}
\end{example}
This example considers the overloaded `eq' function.
Initially, `eq' is instantiated for the base type `nat'.
Subsequently, the instantiation for lists requires us to convey that list
equality is feasible only when
the elements of the list can be compared, that is, there exists a instance $Œ± ‚Üí
  Œ± ‚Üí$ bool.

Instead of focusing exclusively on these individual systems, our exploration
will center on \hmx{}, a HM-based system that remains detached from
the actual constraint domain $X$.
Subsequently, we will proceed to instantiate $X$ using the two showcased
instances of constraints, namely overloading and polymorphic records.

\section{\hmx{}}

\subsection{Introduction}
In this segment, our discussion of \hmx{} will adopt a slightly informal
approach.
We will skip over some specifics and formalities to ensure clarity and
concentrate on
grasping the underlying concepts of the system, rather than deriving a full
formal definition.

\subsection{Syntax}
\begin{figure}[t]
  \centering
  \begin{subfigure}[t]{0.3\textwidth}
    \begin{align*}
      e \ := & \ \ x                    \\
             & | \ Œªx. e                \\
             & | \ e \ e                \\
             & | \ \kwlet x = e \kwin e
    \end{align*}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \begin{align*}
      C \ := & \ \ ‚ä§       \\
             & | \ C ‚àß C   \\
             & | \ œÑ = œÑ   \\
             & | \ ‚àÉŒ±. \ C \\
    \end{align*}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \begin{align*}
      œÑ \ := & \ \ Œ±     \\
             & | \ œÑ ‚Üí œÑ
    \end{align*}
    \begin{align*}
      œÉ \ := & \ \ œÑ             \\
             & | \ ‚àÄ\Vec Œ±.C ‚áí œÑ
    \end{align*}
    \begin{align*}
      Œì \ := & \ \ ‚àÖ           \\
             & | \ Œì , \ x : œÉ
    \end{align*}
  \end{subfigure}
  \caption{Syntax}
\end{figure}

The syntax of \hmx{} is closely related to that of HM.

Expressions $e$ include the constructs found in the simply typed lambda
calculus.
These encompass variables $x$, abstractions $Œªx. \ e$, and applications $e \
  e$.
Additionally, let bindings are present to confine the language to let
polymorphism.

Regarding types, we maintain the distinction between mono types $œÑ$ and
poly types $œÉ$. However, unlike in the context of HM, we are now
able to introduce constraints $C$ to poly types.

The constraint syntax described here constitutes the \emph{minimal} essential
components necessary for the syntax of constraint domain $X$.
The underlying notion is that the constraint syntax is later extended when
instantiating \hmx{}, and
conceivably also the syntax for expressions and types, to incorporate those new
constraints.

A constraint $C$ is either $‚ä§$ (true), a conjunction of two constraints
$C ‚àß C$, an equality between mono types $œÑ = œÑ$, or a projection $‚àÉŒ±. \ C$.
The projection operator introduces a new type variable $Œ±$ to constraint $C$.
Through projection, it becomes possible to express the
existence of a type without the necessity of actually introducing a new
type variable at the type level.
This mechanism proves advantageous within the non-algorithmic typing rules and
type inference algorithms.
Moreover, it actually extends the expressive capacity beyond that of solely
introducing
all type variables present in constraints using the $‚àÄ$ operator\footnote{Refer
  to example 5}.

\subsection{Typing}
\begin{figure}[t]
  \centering
  \begin{subfigure}[t]{0.52\textwidth}
    \centering
    \infer[(\text{Var})]{
      C,\ Œì ‚ä¢ x : œÉ
    }{
      C,\ x : œÉ ‚àà Œì
    }
    \infer{}{}
    \infer[(\text{App})]{
      C,\ Œì ‚ä¢ e‚ÇÅ \ e‚ÇÇ : œÑ‚Ä≤
    }{
      C,\ Œì ‚ä¢ e‚ÇÅ : œÑ ‚Üí œÑ‚Ä≤
      & C, \ Œì ‚ä¢ e‚ÇÇ :  œÑ‚Ä≤
    }
    \infer{}{}
    \infer[(‚àÄ\text{I})]{
      C ‚àß ‚àÉ\Vec Œ±.D,\ Œì ‚ä¢ e : ‚àÄ \Vec Œ±.D ‚áí œÑ
    }{
      {C ‚àß D,}\ Œì ‚ä¢ e : œÑ
      & \Vec Œ± ‚àâ free(C, Œì)
    }
  \end{subfigure}
  \begin{subfigure}[t]{0.42\textwidth}
    \centering
    \infer[(\text{Abs})]{
      C,\ Œì ‚ä¢ Œªx. e : œÑ
    }{
      C,\ (Œì, \ x :  œÑ‚Ä≤) ‚ä¢ e : œÑ
    }
    \infer{}{}
    \infer[(\text{Let})]{
      C,\ Œì ‚ä¢ \kwlet x = e\kwin e‚Ä≤ : œÑ‚Ä≤
    }{
      C,\ Œì ‚ä¢ e : œÉ
      & C,\ (Œì, \ x : œÉ) ‚ä¢ e‚Ä≤ : œÑ‚Ä≤
    }
    \infer{}{}
    \infer[(‚àÄ\text{E})]{
      C, \ Œì ‚ä¢ e : [\Vec œÑ / \Vec Œ±] œÑ
    }{
      C,\ Œì ‚ä¢ e : ‚àÄ \Vec Œ±.C‚Ä≤ ‚áí œÑ
      & {C ‚ä¢·µâ [\Vec œÑ / \Vec Œ±]C‚Ä≤}
    }
  \end{subfigure}
  \caption{Logical Type System $(C, Œì ‚ä¢ e : œÉ)$}
\end{figure}

Our current emphasis will be on the logical type system. Unlike the inference
algorithm, which is also provided for \hmx{}, the logical type system does not
represent a determinable process for typing a provided expression. This is due
to the $(‚àÄ$E$)$ and $(‚àÄ$I$)$ rules lacking syntax direction and being
applicable at various points in the process.

Both $($Abs$)$ and $($App$)$ are the familiar standards
found in the simply typed lambda
calculus and operate on mono types, thus enforcing let
polymorphism.
On the other hand, the $($Var$)$ rule allows us to
retrieve a variable with a poly type, potentially introduced through a let
binding.
The $($Let$)$ rule likewise incorporates let polymorphism by permitting the
expression bound by $x$ to exhibit polymorphism, even though the outcome itself
remains monomorphic.
\subsection{Type Inference}
\section{Instantiating \hmx{}}
\subsection{\hmr{}: Instantiation with Polymorphic Records}
\subsubsection{Extensions}
\begin{figure}[t]
  \centering
  \caption{Syntax}
\end{figure}
\begin{figure}[t]
  \centering
  \caption{Constraints}
\end{figure}
\subsubsection{Example}
\subsection{\hmo{}: Instantiation with Overloading}
\subsubsection{Extensions}
\begin{figure}[t]
  \centering
  \caption{Syntax}
\end{figure}
\begin{figure}[t]
  \centering
  \caption{Constraints}
\end{figure}
\subsubsection{Example}
\section{Metatheory}
\subsection{Soundness}
\subsection{Type Inference}
\section{Related Work \& Conclusion}
\subsection{Related Work}
\subsection{Conclusion}
% mention rust and haskell

\nocite{hmx}
\nocite{sts}
\nocite{atapl}
\printbibliography{}

\end{document}