\documentclass[runningheads]{llncs}

\usepackage{graphicx}
\usepackage{fontspec}
\usepackage{unicode-math}
\usepackage[Latin,Greek]{ucharclasses}
\usepackage{amsmath}
\usepackage{proof}
\usepackage{bigfoot}
\usepackage{minted}
\usepackage{subcaption}
\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}
\usepackage[backend=biber]{biblatex}
\addbibresource{references.bib}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  mathescape
}

\newfontfamily\substitutefont{CMU Serif}
\setTransitionsForGreek{\begingroup\substitutefont}{\endgroup}

% chktex-file 36 
% chktex-file 12

\newcommand{\hmx}{HM($X$)}
\newcommand{\hmr}{HM($\mathcal{R}$)}
\newcommand{\hmo}{HM($\mathcal{O}$)}
\newcommand{\kwlet}{\textbf{let }}
\newcommand{\kwin}{\textbf{ in }}

\title{\includegraphics[width=0.4\textwidth]{logo.png}~\\[1cm] Elaboration on
  \hmx:\\Type Inference with Constraint Types}
\titlerunning{\hmx: Type Inference with Constraint Types}
\institute{Chair of Programming Languages, University of Freiburg \\
  \email{weidner@cs.uni-freiburg.de}}
\author{Marius Weidner}

\begin{document}

\let\oldaddcontentsline\addcontentsline{}
\def\addcontentsline#1#2#3{}
\maketitle
\def\addcontentsline#1#2#3{\oldaddcontentsline{#1}{#2}{#3}}

\begin{abstract}
  We explore \hmx{}$^\text{\cite{hmx}}$, a family of type systems designed to
  combine
  polymorphism, full type inference and constraint types.
  \hmx{} extends the Hindley-Milner type system (HM)$^\text{\cite{hm}}$, which
  already
  limits
  System F, to ensure decidability and unambiguity of full type inference.
  The constraint system $X$ utilized in \hmx{} remains abstract, allowing
  instantiating $X$ with arbitrary constraint systems that meet specific
  criteria.
  This abstraction allows \hmx{} to serve as a model for analyzing various
  constraint-related type features commonly encountered in practice.
  Notable examples include subtyping, substructural
  types and type classes.
  \hmx{} is presented along a sound and complete type inference algorithm that
  remains
  independent of the actual constraint system
  $X$.
  As a result, the work for proving theoretical properties and designing
  inference algorithms for novel constraint-based type systems within an
  HM context is notably simplified.
\end{abstract}

\setcounter{tocdepth}{2}
\tableofcontents
\newpage

\section{Introduction}

\subsection{Polymorphism and Type Inference in HM}
The HM type system represents a well known and understood typing discipline
that
refines System F by establishing constraints that allow type inference
to be decidable.
HM serves as the foundation for numerous real-world functional programming
languages, including Haskell and Rust.

In System F, we can introduce variables for both expressions and types.
The type $âˆ€Î±. \ T$, where $Î±$ binds a new type in $T$,
indicates that an expression of this type is polymorphic over some
arbitrary type $Î±$.
Unfortunately it is undecidable for arbitrary programs to determine when to
introduce and eliminate $âˆ€$-types and in consequence type inference in System F
is undecidable$^\text{\cite{sysf}}$.

Thus, System F is equipped with explicit type abstraction ($Î›Î±. \ e$)
and type
application ($e \ T$) on the syntax level.

The HM type system imposes several restrictions that make type
inference decidable in a polymorphic context. Moreover, HM ensures that the
most general type (the \emph{principal type}) of a any given program is
inferred.
Consequently, there's no need for extra syntax to introduce or eliminate type
variables.
Instead, HM adds let bindings $\kwlet x = eâ‚‚ \kwin eâ‚$ to the language, where
$eâ‚‚$ is the only expression that is allowed to have a polymorphic type.
Other constructs, such as application or variables bound by a lambda
abstractions, cannot inherit polymorphic types.
This constraint is commonly referred to as `let polymorphism'.

In the future, we will label polymorphic types as $Ïƒ$,
where a $âˆ€$-type exists within $Ïƒ$, and we will refer to them as `poly types'.
On the contrary, all other types, including base
types, functions and type variables, will be referred to as `mono types' and
denoted as $Ï„$.

Poly types are further constrained to exclusively permit $âˆ€$-binders at the top
level.
Therefore, a type like $(âˆ€Î±. Î±) â†’ (âˆ€Î±. Î±)$ would not be a valid poly type.
Consequently, we establish that poly types always adhere to the structure
$âˆ€\bar{Î±}. \ Ï„$, where $\bar{Î±} = Î±â‚,..,Î±â‚™$ for some $n âˆˆ â„•$.
By upholding these two restrictions, that is let polymorphism and the exclusion
of
higher-order polymorphism, type inference remains decidable and
yields a principal type.
\begin{example}[Concatination of Lists]
  \begin{lstlisting}
concat : $âˆ€Î±.$ $[Î±] â†’ [Î±] â†’ [Î±]$
concat = $Î»$[].      $Î»$ys. ys           
         $Î»$[x:xs]. $Î»$ys. x : (concat xs ys)   
  \end{lstlisting}
\end{example}
Examples assume the extension with various language features such as
lists and pattern matching.
For convenience, type annotations are given for inferred function types.

In this example, HM would be capable of deducing the type $âˆ€Î±.\ [Î±] â†’ [Î±] â†’
  [Î±]$
for the function `concat'.
This type is in fact the most general type for `concat'.

\subsection{Introducing Constraints on Types}
Although parametric polymorphism is already a powerful abstraction, there are
instances where we desire to constrain type variables solely to instantiations
of types that satisfy certain constraints.
We refer to such types as \emph{constraint types}.
Constraints can exhibit various different forms depending on the type features
present in the actual language.
As an illustration, consider \hmr{}, that is HM extended with
polymorphic records$^\text{\cite{hmr}}$.
In this scenario, it becomes valuable to have the capability to specify that a
type variable $Î±$
should only be instantiated as a record type containing a specific fields.
\begin{example}[Alternative to Selector Syntax on Records for Field `key']
  \begin{lstlisting}
key : $âˆ€Î±, Î².(Î± â‰¤ \{$key : $Î²\})$ $â‡’ Î± â†’ Î²$
key = $Î»${key, ..}. key
  \end{lstlisting}
\end{example}
This example simulates the extraction of a particular field from a record using
pattern matching, conventionally represented as $e.l$ where $l$ denotes a field
label.
Instead of the notation $e.key$, the alternative syntax $key \ e$ could then be
employed.
We introduce two type variables, namely $Î±$ and $Î²$. While $Î²$ exhibits
parametric polymorphism, $Î±$ functions as a constraint type.
The constraint imposed on $Î±$, denoted as $Î± â‰¤ \{$key : $Î²\}$, expresses that
$Î±$ is exclusively permitted to take on a type that corresponds to a record
featuring a `key' field of type $Î²$.
For introducing constraint a $C$ on type variables $\bar{Î±}$, we will adopt the
notation $âˆ€\bar{Î±}.C$ $â‡’ Ï„$.
Multiple constraints will be combined to a single
constraint using conjunction. If the constraint $C$ is the trivial constraint
$âŠ¤$ we may also write $âˆ€\bar{Î±}.$ $Ï„$.

Naturally, we can envision entirely different constraints as well.
Consider a language with overloading and overloading constraints
\hmo{}$^\text{\cite{syso}}$.
In \hmo{}, constraints have the form $x : Î± â†’ Ï„$,
wherein an instance for the overloaded identifier $x$ with type $Î± â†’ Ï„$
is
expected to be present.
\begin{example}[Overloading the Equality Operator for Lists]
  \begin{lstlisting}
eq : nat $â†’$ nat $â†’$ bool
eq = $Î»$0.      $Î»$0.      = $âŠ¤$
     $Î»$suc n. $Î»$suc m. = eq n m 
     $Î»$_.      $Î»$_.      = $âŠ¥$
eq : $âˆ€Î±.($eq $:$ $Î± â†’ Î± â†’$ bool$)$ $â‡’ [Î±] â†’ [Î±] â†’$ bool
eq = $Î»$[].      $Î»$[].      = $âŠ¤$
     $Î»$[x:xs]. $Î»$[y:ys]. = eq x y $âˆ§$ eq xs ys
     $Î»$_.       $Î»$_.       = $âŠ¥$
  \end{lstlisting}
\end{example}
This example considers the overloaded `eq' function.
Initially, `eq' is instantiated for the base type `nat'.
Subsequently, the instantiation for lists requires us to express that
list
equality is feasible only when
the elements of the list can be compared, that is, there exists a
instance $Î± â†’ Î± â†’$ bool.

Instead of focusing exclusively on these individual systems, our
exploration
will center on \hmx{}, a HM-based system that remains detached from
the actual constraint domain $X$.
Subsequently, we will proceed to instantiate $X$ to a constraint system
$ğ“¡$
that supports polymorphic records, similar to \hmr{}.

\section{\hmx{}}

\subsection{Introduction}
In this segment, our discussion of \hmx{} will adopt a slightly informal
approach.
We will skip over some specifics and formalities to ensure clarity and
concentrate on
grasping the underlying concepts of the system, rather than deriving a
full
formal definition.

\subsection{Syntax \& Constraints}
\begin{figure}[t]
  \centering
  \begin{subfigure}[t]{0.3\textwidth}
    \begin{align*}
      e \ := & \ \ x                    \\
             & | \ Î»x. e                \\
             & | \ e \ e                \\
             & | \ \kwlet x = e \kwin e
    \end{align*}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \begin{align*}
      C \ := & \ \ âŠ¤       \\
             & | \ C âˆ§ C   \\
             & | \ Ï„ = Ï„   \\
             & | \ âˆƒÎ±. \ C \\
    \end{align*}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \begin{align*}
      Ï„ \ := & \ \ Î±     \\
             & | \ Ï„ â†’ Ï„
    \end{align*}
    \begin{align*}
      Ïƒ \ := & \ \ Ï„             \\
             & | \ âˆ€\Vec Î±.C â‡’ Ï„
    \end{align*}
    \begin{align*}
      Î“ \ := & \ \ âˆ…           \\
             & | \ Î“ , \ x : Ïƒ
    \end{align*}
  \end{subfigure}
  \caption{Syntax}
\end{figure}

The syntax of \hmx{} is closely related to that of HM.

Expressions $e$ include the constructs found in the simply typed lambda
calculus, more specifically variables $x$, abstractions $Î»x. \ e$, and
applications $e \
  e$.
Additionally, let bindings are present to constrain the language to let
polymorphism.

We maintain the distinction between mono types $Ï„$ and
poly types $Ïƒ$. However, we are now
able to introduce constraints $C$ in $âˆ€$-types.

Typing contexts $Î“$ are either the empty context $âˆ…$ or an extension of
another
context with the type $Ï„$ of a variable $x$, denoted as $Î“, \ x : Ïƒ$.

The constraint syntax described here forms the \emph{minimal} essential
components necessary for the syntax of constraint domain $X$.
The underlying notion is that the constraint syntax is later extended
when
instantiating \hmx{}, and
consequently also the syntax for expressions and types, to incorporate
those
new
constraints.

A constraint $C$ is either $âŠ¤$ (true), a conjunction of two constraints
$C âˆ§ C$, an equality between mono types $Ï„ = Ï„$, or a projection $âˆƒÎ±. \ C$.
The projection operator introduces a new type variable $Î±$ to constraint
$C$.
Through projection, it becomes possible to express the
existence of a type without the necessity of actually introducing a new
type variable at the type level.
This mechanism proves advantageous within both the non-algorithmic typing
rules
and
type inference algorithms.
Moreover, it actually extends the expressive capacity beyond that of
solely introducing all type variables present in constraints using
the $âˆ€$-operator.

We use the notation $C âŠ¢ D$ to indicate that we are verifying that some
constraint $C$ implies another constraint $D$.
Both the projection and the equality operator must satisfy several
straightforward conditions, such as $C âŠ¢ âˆƒ\bar{Î±}. \ C$ or $(Ï„â‚ = Ï„â‚‚) âŠ¢ (Ï„[Ï„â‚]
  = Ï„[Ï„â‚‚])$, where both $Ï„[Ï„â‚]$ and $Ï„[Ï„â‚‚]$ substitute $Ï„â‚$ and $Ï„â‚‚$ at the
same
position in $Ï„$. We won't cover all the other, mostly trivial conditions.

\subsection{Typing}
\begin{figure}[t]
  \centering
  \begin{subfigure}[t]{0.52\textwidth}
    \centering
    \infer[(\text{Var})]{
      C,\ Î“ âŠ¢ x : Ïƒ
    }{
      C,\ x : Ïƒ âˆˆ Î“
    }
    \infer{}{}
    \infer[(\text{App})]{
      C,\ Î“ âŠ¢ eâ‚ \ eâ‚‚ : Ï„â€²
    }{
      C,\ Î“ âŠ¢ eâ‚ : Ï„ â†’ Ï„â€²
      & C, \ Î“ âŠ¢ eâ‚‚ :  Ï„â€²
    }
    \infer{}{}
    \infer[(âˆ€\text{I})]{
      C âˆ§ âˆƒ\Vec Î±.D,\ Î“ âŠ¢ e : âˆ€ \Vec Î±.D â‡’ Ï„
    }{
      {C âˆ§ D,}\ Î“ âŠ¢ e : Ï„
      & \Vec Î± âˆ‰ free(C, Î“)
    }
  \end{subfigure}
  \begin{subfigure}[t]{0.42\textwidth}
    \centering
    \infer[(\text{Abs})]{
      C,\ Î“ âŠ¢ Î»x. e : Ï„
    }{
      C,\ (Î“, \ x :  Ï„â€²) âŠ¢ e : Ï„
    }
    \infer{}{}
    \infer[(\text{Let})]{
      C,\ Î“ âŠ¢ \kwlet x = e\kwin eâ€² : Ï„â€²
    }{
      C,\ Î“ âŠ¢ e : Ïƒ
      & C,\ (Î“, \ x : Ïƒ) âŠ¢ eâ€² : Ï„â€²
    }
    \infer{}{}
    \infer[(âˆ€\text{E})]{
      C, \ Î“ âŠ¢ e : [\Vec Ï„ / \Vec Î±] Ï„
    }{
      C,\ Î“ âŠ¢ e : âˆ€ \Vec Î±.D â‡’ Ï„
      & {C âŠ¢ [\Vec Ï„ / \Vec Î±]D}
    }
  \end{subfigure}
  \caption{Logical Type System $(C, Î“ âŠ¢ e : Ïƒ)$}
\end{figure}

Our current emphasis will be on the logical type system.
The typing relation ($C, Î“ âŠ¢ e : Ïƒ$) in \hmx{} extends the standard
typing
relation ($Î“ âŠ¢ e : T$) by integrating the propagation of a constraint $C$
across the typing rules. The constraint $C$ must be in a solved form.
Informally, this means that $C$ should be a satisfiable constraint and it
should not contain equality predicates. Equality constraints should be
resolved
through some form of unification.

Unlike the inference
algorithm, which is also provided for \hmx{}, the logical type system
does not represent a determinable process for typing a provided expression.
This is due to the $(âˆ€$E$)$ and $(âˆ€$I$)$ rules lacking syntax direction and
being applicable at various points in the typing derivation.

Both $($Abs$)$ and $($App$)$ are the familiar standards
found in the simply typed lambda
calculus and operate on mono types, thus enforcing let
polymorphism.
On the other hand, the $($Var$)$ rule allows us to
retrieve a variable with a poly type, potentially introduced through a
let
binding.
The $($Let$)$ rule likewise enforces let polymorphism by permitting the
expression bound by $x$ to have a poly type, even though the resulting
overall type
remains monomorphic.

The $(âˆ€$I$)$ and $(âˆ€$E$)$ rules are particularly interesting as they
enable the introduction and elimination of type variable bindings and
constraints.
Through the use of the $(âˆ€$I$)$ rule, we can assign an arbitrary
expression $e$, with current type $Ï„$, a poly type $âˆ€ \Vec Î±.D â‡’ Ï„$,
introducing new type variables $\Vec Î±$ and the constraint $D$.
Hence, we check that expression $e$ has type $Ï„$ under the assumption of
$C âˆ§ D$.
Additionally, we add the constraint $âˆƒ\bar{Î±}. D$ in the conclusion of
the rule using conjunction.
This addition is not strictly necessary but expresses that $D$ should be,
at the very least, satisfiable, thereby enabling the detection of a type
error arising from an unsatisfiable constraint at an earlier stage.

Interestingly, there are alternative approaches to handling $D$ in the
conclusion. For instance, one could entirely eliminate the satisfiability check
$^\text{\cite{nosat}}$ or opt for a less restricted$^\text{\cite{weaksat}}$ or
more restricted satisfiability
check$^\text{\cite{strongsat}}$. However, the solution presented in \hmx{}
aligns most closely
with our intuition, asserting that it is indeed true that $D$ must be at least
satisfiable for some $\bar Î±$. One of the strengths of \hmx{} lies in the
introduction of the projection operator, a novel idea not found in the other
variants.

The $(âˆ€$E$)$ rule allows us to eliminate a $âˆ€$-type by substituting all
type variables $\bar{Î±}$ with mono types $\bar{Ï„}$ in $Ï„$. This substitution
of all bound variables with mono types results in a mono type again. More
importantly we need to verify that the constraint $D$ introduced by the
$âˆ€$-type is satisfied when we substitute all $\bar{Î±}$ by $\bar{Ï„}$ in $D$, all
while assuming the propagated constraint $C$.\footnote{
The action of substitution on constraints can again be encoded
\emph{as constraint}.
We have $[\Vec Ï„ / \Vec Î±] (â‹€_{i âˆˆ â„•} Cáµ¢) â‰¡ â‹€_{i âˆˆ â„•} ([\Vec Ï„ / \Vec
      Î±]Cáµ¢) â‰¡
  â‹€_{i âˆˆ â„•} (âˆƒ\bar{Î±}. Cáµ¢ âˆ§ â‹€_{j}(Ï„â±¼ = Î±â±¼))$.
Moreover, we can extend this notion for arbitrary predicates $P$ that might be
part of the constraint language, i.e. $[\Vec Ï„ / \Vec Î±]P â‰¡ âˆƒ\bar{Î±}. P âˆ§
  â‹€_{j}(Ï„â±¼ = Î±â±¼)$.
}

\subsection{Type Inference}
Type inference in \hmx{} consists of two sequential steps. Initially, a
typing
problem is transformed into a constraint $D$ within the constraint system
$X$.
Subsequently, constraint $D$ undergoes normalization, a process involving
the
computation of a substitution $Ïƒ$ and a constraint $C$ in solved form.

Normalization
guarantees that $ÏƒC$ (where $ÏƒC$ is the application of substitution $Ïƒ$
to constraint $C$) implies $D$ and that $ÏƒC$ is a constraint in solved form.
To ensure that a typing problem has the principal type property, it's
necessary that constraints within $X$ exhibit the most general normalizers.
Analogous to types, we require that $X$ must have the
\emph{principal constraint} property.
This property ensures that the most general constraint results from
normalization.
Informally, this means for every constraint $D âˆˆ X$ we can compute a
normalized constraint in solved form $ÏƒC$ where $Ïƒ$ is the minimal
substitution necessary to transform $D$ into a solved form constraint $ÏƒC$
and $C$ implies $D$.
In the event that the constraint domain is the trivial constraint domain
$\top$, the normalization procedure corresponds to the computation of the
most general unifier within the Algorithm $W$ employed in HM.

The actual inference algorithm takes four inputs: A substitution $Ïƒ$, A
constraint in solved form $C$, $Î“$, and $e$.
We write $Ïƒ, C, Î“ âŠ¢ e : Ï„$ when we use the inference algorithm to deduce
type $Ï„$ for $e$.
Initially, the first three are empty or trivially satisfied respectively, while
$e$ represents the expression for which we are deducing the type.
Within the algorithm, we perform a case split on expressions, all the
while ensuring that recursive calls maintain the invariant that $ÏƒC$
remains a principal constraint by normalization.
The resulting type is then obtained by applying $Ïƒ$ to $Ï„$.

\section{Instantiating \hmx{}}
\subsection{\hmr{}: Instantiation with Polymorphic Records}
\begin{figure}[t]
  \begin{subfigure}[t]{0.3\textwidth}
    \begin{align*}
      e \ := & \ \dots                            \\
             & | \ \{láµ¢ = eáµ¢\} \text{ for } i âˆˆ â„• \\
             & | \ e.l                            \\
    \end{align*}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \begin{align*}
      C \ := & \ \dots           \\
             & | \ Ï„ â‰¤ \{l : Ï„\}
    \end{align*}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \begin{align*}
      Ï„ \ := & \ \dots                            \\
             & | \ \{láµ¢ : Ï„áµ¢\} \text{ for } i âˆˆ â„•
    \end{align*}
  \end{subfigure}
  \infer[(\text{Rec})]{
    C, \ Î“ âŠ¢ \{láµ¢ = eáµ¢\} : \{láµ¢ : Ï„áµ¢\}
  }{
    C,\ Î“ âŠ¢ eáµ¢ : Ï„áµ¢
  }
  \infer[(\text{Sel})]{
    C,\ Î“ âŠ¢ e.l : Ï„
  }{
    C, \ Î“ âŠ¢ e : \{.., l : Ï„, ..\}
  }
  \centering
  \caption{\hmr{} Extensions}
\end{figure}
We will now instantiate $X$ to $ğ“¡$, thus extending HM with
polymorphic records and related constraints. Our focus will be only on the
additions to the syntax, typing rules and minimal constraint language provided
by \hmx{}.

The extensions introduce record expressions and types to the language, along
with the
record subtyping constraint $Ï„ â‰¤ \{l âˆ¶ Ï„'\}$, which says that $Ï„$ is a record
and
must have at least the field $l$ of type $Ï„'$.
Moreover, a record $\{láµ¢ = eáµ¢\}$ has type $\{láµ¢ : Ï„áµ¢\}$ only if each
$eáµ¢$ is of type $Ï„áµ¢$. Additionally, selecting a label $l$ from $e$ is assigned
type $Ï„$ if $e$ is a record with a field $l$ of type $Ï„$.

As mentioned, our desire is for the constraint domain $ğ“¡$ to possess the
principal constraint property. Initially, we impose some conditions on record
subtyping constraints and subsequently examine when it is in solved form. We
will not discuss some straightforward conditions of record constraints, such as
the fact that every record trivially satisfies the subtyping constraint if it
contains the corresponding field of the correct type, i.e.
$âŠ¢ \{.., l:Ï„, ..\} â‰¤ \{l : Ï„\}$.

We require that the order of labels is irrelevant. Formally, this
implies that $âŠ¢ \{láµ¢ = eáµ¢\} = \{l_{Ï€(i)} = e_{Ï€(i)}\}$, where $Ï€$ represents a
permutation. Additionally, we disallow recursive constraints in the form of $Î±
  â‰¤ \{l : Ï„\}$ where $Ï„$ depends on the type variable $Î±$. The condition $Î±
  â‰¤ \{l : Ï„\}$ also is the only subtyping record in solved form.
The constraint system $ğ“¡$ indeed satisfies the principal constraint property,
and as a result, \hmx{} grants us a sound and complete type inference algorithm
for our system. It also provides a proof of the soundness of \hmr{} itself.

\begin{example}[Using the Projection Operator to Unpack Nested Records]
  \begin{lstlisting}
unpack : $âˆ€Î±âˆƒÎ².(Î± â‰¤ \{$foo $ : Î²\} âˆ§ Î² â‰¤ \{$bar $ : $ nat$\}) â‡’ Î± â†’$ nat
unpack = $Î»\{$foo $ : \{$bar$, ..\}, ..\}$. bar
  \end{lstlisting}
\end{example}
In this example, we use the projection operator to extract a field from a
nested record. The use of projection, rather than introducing a second type
variable for $Î²$, is chosen because we only refer to $Î²$ in the constraint and
not in the type signature.

\section{Metatheory}

\subsection{Introduction}
We will now look into some metatheoretical properties of both the logical type
system and the inference algorithm presented in \hmx{}.
In this discussion, we will once again adopt an informal approach, skipping
some specifics, and omitting the proofs entirely.

\subsection{Soundness}
The logical type system of \hmx{} is proven to be sound. Soundness essentially
states the idea that `well typed programs don't go wrong'.
In the original paper,
this proof is established through denotational semantics, where mathematical
objects are constructed for both types and terms, and the statements are proven
within the domain of mathematics. Later, it was also proven using operational
semantics, where evaluation is described as a reduction relation $e â†ª e$ on
expressions$^\text{\cite{sts}}$.
We will concentrate on the latter, where the soundness property is established
by ensuring that the language satisfies both \emph{progress} and \emph{subject
  reduction}.
The actual paper also includes the modeling of memory, so the statements
proven there may vary slightly from the ones discussed here.

First and foremost, we must ensure that the constraint system is sound. The
constraint system is sound if, for every constraint in solved form, $âŠ¢ âˆƒÎ±. \ C$
implies that there exists some type $Ï„$ such that
$âŠ¢ [Î±/Ï„]C â‰¡ \ âŠ¢ âˆƒÎ±. \ (Î± = Ï„) âˆ§ C$.
In essence, this implies that every existentially quantified constraint must be
actually satisfiable for some type $Ï„$.

To establish progress for \hmx{}, we must prove that if $e$ is a
well-typed expression, meaning $C, âˆ… âŠ¢ e : Ï„$, then either $e$ is already a
fully reduced value or it can be reduced to some other expression,
i.e. $e â†ª e'$. Since this statement only holds in the empty context $âˆ…$, we
need to ensure that there is no evaluation of expressions where non-substituted
variables still exist. This can be achieved using call-by-value semantics.

Finally, to establish subject reduction, we need to show that for every
well-typed expression $C, Î“ âŠ¢ e : Ï„$, if $e â†ª e'$ then $e'$ is also well-typed,
specifically with the same type, i.e. $C, Î“ âŠ¢ e' : Ï„$.

\subsection{Type Inference}
The soundness and completeness properties of the inference algorithm are a bit
more challenging to articulate since we discussed the inference algorithm only
informally. We will only discuss the key ideas.

\hmx{} establishes soundness for the inference algorithm by relating the
algorithm to the logical type system. We
prove that if $Ïƒ, C, Î“ âŠ¢ e : Ï„$, then $C, Î“ âŠ¢ e : Ï„$. In essence, we check
that if the algorithm deduces the type $Ï„$ for $e$, then $e$ has type $Ï„$ in
the logical type system.

Completeness, in essence, is the reverse. We must show that if the
logical type system deduces $Ï„$ for $e$, then the algorithm would also infer
the same type $Ï„$ for $e$.

\section{Related Work \& Conclusion}
\subsection{Related Work}
There are several constraint-based languages based on HM, such as
\hmr{}$^\text{\cite{hmr}}$ and \hmo{}$^\text{\cite{syso}}$.
Additionally, there are alternative approaches to imposing arbitrary constraint
systems on types, for example the theory of qualified types$^\text{\cite{tqt}}$.

\hmx{} is also the subject of various follow-up papers, including proofs of
other noteworthy properties$^\text{\cite{phmx}}$, its connection to CSP
solving$^\text{\cite{clp}}$ and the previously discussed syntactic type
soundness$^\text{\cite{sts}}$.

\subsection{Conclusion}
We discussed \hmx{}, a language based on HM that incorporates an abstract
constraint system $X$. We outlined the extensions that \hmx{} introduces in
contrast to HM, providing an informal understanding of the core concepts of
\hmx{} and the role of $X$. Furthermore, we instantiated $X$ with a specific
constraint domain $ğ“¡$.
Lastly, we explored the metatheoretical properties of \hmx{}.
These properties hold particular significance because of their independence
from the actual constraint domain $X$.

\nocite{atapl}
\printbibliography{}

\end{document}