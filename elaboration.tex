\documentclass[runningheads]{llncs}

\usepackage{graphicx}
\usepackage{fontspec}
\usepackage{unicode-math}
\usepackage[Latin,Greek]{ucharclasses}
\usepackage{amsmath}
\usepackage{proof}
\usepackage{bigfoot}
\usepackage{minted}
\usepackage{subcaption}
\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}
\usepackage[backend=biber]{biblatex}
\addbibresource{references.bib}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  mathescape
}

\newfontfamily\substitutefont{CMU Serif}
\setTransitionsForGreek{\begingroup\substitutefont}{\endgroup}

% chktex-file 36 
% chktex-file 12

\newcommand{\hmx}{HM($X$)}
\newcommand{\hmr}{HM($\mathcal{R}$)}
\newcommand{\hmo}{HM($\mathcal{O}$)}
\newcommand{\kwlet}{\textbf{let }}
\newcommand{\kwin}{\textbf{ in }}

\title{\includegraphics[width=0.4\textwidth]{logo.png}~\\[1cm] Elaboration on
  \hmx:\\Type Inference with Constraint Types}
\titlerunning{\hmx: Type Inference with Constraint Types}
\institute{Chair of Programming Languages, University of Freiburg \\
  \email{weidner@cs.uni-freiburg.de}}
\author{Marius Weidner}

\begin{document}

\let\oldaddcontentsline\addcontentsline{}
\def\addcontentsline#1#2#3{}
\maketitle
\def\addcontentsline#1#2#3{\oldaddcontentsline{#1}{#2}{#3}}

\begin{abstract}
  We explore \hmx{}\cite{hmx}, a family of type systems designed to
  combine
  polymorphism, full type inference and constraint types.
  \hmx{} extends the Hindley-Milner type system (HM)\cite{hm}, which already
  limits
  System F, to ensure decidability and unambiguity of full type inference.
  The constraint system $X$ utilized in \hmx{} remains abstract, allowing
  instantiating $X$ with arbitrary constraint systems that meet specific
  criteria.
  This abstraction allows \hmx{} to serve as a model for analyzing various
  constraint-related type features commonly encountered in practice.
  Notable examples include subtyping, substructural
  types and type classes.
  \hmx{} is presented along a sound and complete type inference algorithm that
  remains
  independent of the actual constraint system
  $X$.
  As a result, the work for proving theoretical properties and designing
  inference algorithms for novel constraint-based type systems within an
  HM context is notably simplified.
\end{abstract}

\setcounter{tocdepth}{2}
\tableofcontents
\newpage

\section{Introduction}

\subsection{Polymorphism and Full Type Inference in HM}
The HM type system represents a well known and understood typing discipline
that
refines System F by establishing constraints that allow type inference
to be decidable.
HM serves as the foundation for numerous real-world functional programming
languages, including Haskell and Rust.

In System F, we can introduce variables for both expressions and types.
The type $∀α. \ T$, where $α$ binds a new type in $T$,
indicates that an expression of this type is polymorphic over some
arbitrary type $α$.
Unfortunately it is undecidable for arbitrary programs to determine when to
introduce and eliminate $∀$-types and in consequence type inference in System F
is undecidable\cite{sysf}.

Thus, System F is equipped with explicit type abstraction ($Λα. \ e$)
and type
application ($e \ T$) on the syntax level.

The HM type system imposes several restrictions that make type
inference decidable in a polymorphic context. Moreover, HM ensures that the
most general type (the \emph{principal type}) of a any given program is
inferred.
Consequently, there's no need for extra syntax to introduce or eliminate type
variables.
Instead, HM adds let bindings $\kwlet x = e₂ \kwin e₁$ to the language, where
$e₂$ is the only expression that is allowed to have a polymorphic type.
Other constructs, such as application or variables bound by a lambda
abstractions, cannot inherit polymorphic types.
This constraint is commonly referred to as `let polymorphism'.

In the future, we will label polymorphic types as $σ$,
where a $∀$-type exists within $σ$, and we will refer to them as `poly types'.
On the contrary, all other types, including base
types, functions and type variables, will be referred to as `mono types' and
denoted as $τ$.

Poly types are further constrained to exclusively permit $∀$-binders at the top
level.
Therefore, a type like $(∀α. α) → (∀α. α)$ would not be a valid poly type.
Consequently, we establish that poly types always adhere to the structure
$∀\bar{α}. \ τ$, where $\bar{α} = α₁,..,αₙ$.
By upholding these two restrictions, that is let polymorphism and the exclusion
of
higher-order polymorphism, type inference remains decidable and
yields a principal type.
\begin{example}[Concatination of Lists]
  \begin{lstlisting}
concat : $∀α.$ $[α] → [α] → [α]$
concat = $λ$[].      $λ$ys. ys           
         $λ$[x:xs]. $λ$ys. x : (concat xs ys)   
  \end{lstlisting}
\end{example}
Examples assume the extension with various language features such as
lists and pattern matching.
For convenience, type annotations are given for inferred function types.

In this example, HM would be capable of deducing the type $∀α.\ [α] → [α] →
  [α]$
for the function `concat'.
This type is in fact the most general type for `concat'.

\subsection{Introducing Constraints on Types}
Although parametric polymorphism is already a powerful abstraction, there are
instances where we desire to constrain type variables solely to instantiations
to types that satisfy certain constraints.
We refer to such types as \emph{constraint types}.
Constraints can exhibit various different forms depending on the type features
present in the actual language.
As an illustration, consider HM$_𝓡$, that is HM extended with
polymorphic records\cite{hmr}.
In this scenario, it becomes valuable to have the capability to specify that a
type variable $α$
should solely be instantiated as a record type containing a specific fields.
\begin{example}[Alternative to Selector Syntax on Records for Field `key']
  \begin{lstlisting}
key : $∀α, β.(α ≤ \{$key : $β\})$ $⇒ α → β$
key = $λ${key : β, ..}. key
  \end{lstlisting}
\end{example}
This example simulates the extraction of a particular field from a record,
conventionally
represented as $e.l$ where $l$ denotes a field label.
We simulate the extraction of  the field `key'.
Instead of the notation $e.key$, the alternative syntax $key \ e$ could then be
employed.\footnote{
  Simulating label syntax in this way is a component of a possible translation
  process from HM$_𝓡$ to HM$_𝓞$.

}
We introduce two type variables, namely $α$ and $β$. While $β$ exhibits
parametric polymorphism, $α$ functions as a constraint type.
The constraint imposed on $α$, denoted as $α ≤ \{$key : $β\}$, expresses that
$α$ is exclusively permitted to take on a type that corresponds to a record
featuring a `key' field of type $β$.
For introducing constraint a $C$ on type variables $\bar{α}$, we will adopt the
notation $∀\bar{α}.C$ $⇒ τ$.
Multiple constraints will be combined to a single
constraint using conjunction. If the constraint $C$ is the trivial constraint
$⊤$ we may also write $∀\bar{α}.$ $τ$.

Naturally, we can envision entirely different constraints as well.
Consider a language with overloading and overloading constraints
HM$_𝓞$\cite{syso}.
In HM$_𝓞$, constraints have the form $x : α → τ$,
wherein an instance for the overloaded identifier $x$ with type $α → τ$ is
expected to be present.
\begin{example}[Overloading the Equality Operator for Lists]
  \begin{lstlisting}
eq : nat $→$ nat $→$ bool
eq = $λ$0.      $λ$0.      = $⊤$
     $λ$suc n. $λ$suc m. = eq n m 
     $λ$_.      $λ$_.      = $⊥$
eq : $∀α.($eq $:$ $α → α →$ bool$)$ $⇒ [α] → [α] →$ bool
eq = $λ$[].      $λ$[].      = $⊤$
     $λ$[x:xs]. $λ$[y:ys]. = eq x y $∧$ eq xs ys
     $λ$_.       $λ$_.       = $⊥$
  \end{lstlisting}
\end{example}
This example considers the overloaded `eq' function.
Initially, `eq' is instantiated for the base type `nat'.
Subsequently, the instantiation for lists requires us to express that list
equality is feasible only when
the elements of the list can be compared, that is, there exists a instance $α →
  α →$ bool.

Instead of focusing exclusively on these individual systems, our exploration
will center on \hmx{}, a HM-based system that remains detached from
the actual constraint domain $X$.
Subsequently, we will proceed to instantiate $X$ to a constraint system $𝓡$
that supports polymorphic records, similar to HM${_𝓡}$.

\section{\hmx{}}

\subsection{Introduction}
In this segment, our discussion of \hmx{} will adopt a slightly informal
approach.
We will skip over some specifics and formalities to ensure clarity and
concentrate on
grasping the underlying concepts of the system, rather than deriving a full
formal definition.

\subsection{Syntax}
\begin{figure}[t]
  \centering
  \begin{subfigure}[t]{0.3\textwidth}
    \begin{align*}
      e \ := & \ \ x                    \\
             & | \ λx. e                \\
             & | \ e \ e                \\
             & | \ \kwlet x = e \kwin e
    \end{align*}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \begin{align*}
      C \ := & \ \ ⊤       \\
             & | \ C ∧ C   \\
             & | \ τ = τ   \\
             & | \ ∃α. \ C \\
    \end{align*}
  \end{subfigure}
  \begin{subfigure}[t]{0.3\textwidth}
    \begin{align*}
      τ \ := & \ \ α     \\
             & | \ τ → τ
    \end{align*}
    \begin{align*}
      σ \ := & \ \ τ             \\
             & | \ ∀\Vec α.C ⇒ τ
    \end{align*}
    \begin{align*}
      Γ \ := & \ \ ∅           \\
             & | \ Γ , \ x : σ
    \end{align*}
  \end{subfigure}
  \caption{Syntax}
\end{figure}

The syntax of \hmx{} is closely related to that of HM.

Expressions $e$ include the constructs found in the simply typed lambda
calculus, more specifically variables $x$, abstractions $λx. \ e$, and
applications $e \
  e$.
Additionally, let bindings are present to constrain the language to let
polymorphism.

We maintain the distinction between mono types $τ$ and
poly types $σ$. However, we are now
able to introduce constraints $C$ in $∀$-types.

The constraint syntax described here forms the \emph{minimal} essential
components necessary for the syntax of constraint domain $X$.
The underlying notion is that the constraint syntax is later extended when
instantiating \hmx{}, and
consequently also the syntax for expressions and types, to incorporate those
new
constraints.

A constraint $C$ is either $⊤$ (true), a conjunction of two constraints
$C ∧ C$, an equality between mono types $τ = τ$, or a projection $∃α. \ C$.
The projection operator introduces a new type variable $α$ to constraint $C$.
Through projection, it becomes possible to express the
existence of a type without the necessity of actually introducing a new
type variable at the type level.
This mechanism proves advantageous within both the non-algorithmic typing rules
and
type inference algorithms.
Moreover, it actually extends the expressive capacity beyond that of solely
introducing
all type variables present in constraints using the $∀$-operator\footnote{Refer
  to example 5}.

\subsection{Typing}
\begin{figure}[t]
  \centering
  \begin{subfigure}[t]{0.52\textwidth}
    \centering
    \infer[(\text{Var})]{
      C,\ Γ ⊢ x : σ
    }{
      C,\ x : σ ∈ Γ
    }
    \infer{}{}
    \infer[(\text{App})]{
      C,\ Γ ⊢ e₁ \ e₂ : τ′
    }{
      C,\ Γ ⊢ e₁ : τ → τ′
      & C, \ Γ ⊢ e₂ :  τ′
    }
    \infer{}{}
    \infer[(∀\text{I})]{
      C ∧ ∃\Vec α.D,\ Γ ⊢ e : ∀ \Vec α.D ⇒ τ
    }{
      {C ∧ D,}\ Γ ⊢ e : τ
      & \Vec α ∉ free(C, Γ)
    }
  \end{subfigure}
  \begin{subfigure}[t]{0.42\textwidth}
    \centering
    \infer[(\text{Abs})]{
      C,\ Γ ⊢ λx. e : τ
    }{
      C,\ (Γ, \ x :  τ′) ⊢ e : τ
    }
    \infer{}{}
    \infer[(\text{Let})]{
      C,\ Γ ⊢ \kwlet x = e\kwin e′ : τ′
    }{
      C,\ Γ ⊢ e : σ
      & C,\ (Γ, \ x : σ) ⊢ e′ : τ′
    }
    \infer{}{}
    \infer[(∀\text{E})]{
    C, \ Γ ⊢ e : [\Vec τ / \Vec α] τ
    }{
    C,\ Γ ⊢ e : ∀ \Vec α.D ⇒ τ
    & {C ⊢ [\Vec τ / \Vec α]D}
    }
  \end{subfigure}
  \caption{Logical Type System $(C, Γ ⊢ e : σ)$}
\end{figure}

Our current emphasis will be on the logical type system.
The typing relation ($C, Γ ⊢ e : σ$) in \hmx{} extends the standard typing
relation ($Γ ⊢ e : T$) by integrating the propagation of a constraint $C$
across the typing rules. The constraint $C$ must be in a solved form.
Informally, this means that $C$ should be a satisfiable constraint and it
should not contain equality predicates. Equality constraints should be resolved
through some form of unification.

Unlike the inference
algorithm, which is also provided for \hmx{}, the logical type system does not
represent a determinable process for typing a provided expression. This is due
to the $(∀$E$)$ and $(∀$I$)$ rules lacking syntax direction and being
applicable at various points in the typing derivation.

Both $($Abs$)$ and $($App$)$ are the familiar standards
found in the simply typed lambda
calculus and operate on mono types, thus enforcing let
polymorphism.
On the other hand, the $($Var$)$ rule allows us to
retrieve a variable with a poly type, potentially introduced through a let
binding.
The $($Let$)$ rule likewise enforces let polymorphism by permitting the
expression bound by $x$ to have a poly type, even though the resulting
overall type
remains monomorphic.
The $(∀$I$)$ and $(∀$E$)$ rules are particularly interesting as they enable the
introduction and elimination of type variable bindings and constraints.
Through the use of the $(∀$I$)$ rule, we can assign an arbitrary expression
$e$, with current type $τ$, a poly type $∀ \Vec α.D ⇒ τ$, introducing new type
variables $\Vec α$ and the constraint $D$.
Hence, we check that expression $e$ has type $τ$ under the assumption of
constraint $D$ in addition to the existing constraint $C$.
Additionally, we add the constraint $∃\bar{α}. D$ in the conclusion of the
rule using conjunction.
This addition is not strictly necessary but expresses that $D$ should be, at
the very least, satisfiable, thereby enabling the detection of a type error
arising from an unsatisfiable constraint at an earlier stage.
The $(∀$E$)$ rule allows us to eliminate a $∀$-type by substituting all type
variables $\bar{α}$ with mono types $\bar{τ}$ in $τ$. This substitution of all
bound variables with mono types results in a mono type again. More importantly
we need to verify that the constraint $D$ introduced by the $∀$-type is
satisfied when we substitute all $\bar{α}$ by $\bar{τ}$ in $D$, all while
assuming the propagated constraint $C$.\footnote{
The action of substitution on constraints can again be encoded \emph{as
  constraint}.
We have $[\Vec τ / \Vec α] (⋀_{i ∈ ℕ} Cᵢ) ≡ ⋀_{i ∈ ℕ} ([\Vec τ / \Vec α]Cᵢ) ≡
  ⋀_{i ∈ ℕ} (∃\bar{α}. Cᵢ ∧ ⋀_{j}(τⱼ = αⱼ))$.

}

\subsection{Type Inference}
Type inference in \hmx{} consists of two sequential steps. Initially, a typing
problem is transformed into a constraint $D$ within the constraint system $X$.
Subsequently, constraint $D$ undergoes normalization, a process involving the
computation of a substitution $σ$ and a constraint $C$ in solved form. 

Normalization
guarantees that $σC$ (where $σC$ is the application of substitution $σ$ to constraint $C$)
implies $D$ and that $σC$ is a constraint in solved form.
To ensure that a typing problem has the principal type property, it's necessary
that constraints within $X$ exhibit the most general normalizers. Analogous to
types, we require that $X$ must have the \emph{principal constraint} property.
This property ensures that the most general constraints results from
normalization. 
Informally, this means for every constraint $D ∈ X$ we can compute a
normalized constraint in solved form $σC$ where $σ$ is the minimal substitution
necessary to transform $D$ into a solved form constraint $σC$ and $C$ implies
$D$. More formally, a solved constraint $σC$ is a most
general normalizer of constraint $φD$, if $φ ≤ σ$ (i.e. $∃χ(φ∘χ = σ)$, thus $φ$
can be extended with $χ$ to $σ$), $C ⊢ σD$, $σC = C$ and for all other solved
normal form $σ'C'$ we have that $σ' ≤ σ$ and $C' ⊢ σ'C$.

In the event that the constraint domain is the trivial constraint domain $\top$, the normalization procedure corresponds to the computation of the most general unifier within the Algorithm $W$ employed in HM.

The actual inference algorithm takes four inputs: $σ$, $C$, $Γ$, and $e$. Initially, the first three are empty, while $e$ represents the expression for which we are deducing the type. 
Within the algorithm, we perform a case split on expressions, all the while ensuring that recursive calls maintain the invariant that $σC$ remains a principal constraint by normalization.

\section{Instantiating \hmx{}}
\subsection{\hmr{}: Instantiation with Polymorphic Records}
\subsubsection{Extensions}
\begin{figure}[t]
  \centering
  \caption{Syntax}
\end{figure}
\begin{figure}[t]
  \centering
  \caption{Constraints}
\end{figure}
\subsubsection{Example}
\section{Metatheory}
\subsection{Soundness}
\subsection{Type Inference}
\section{Related Work \& Conclusion}
\subsection{Related Work}
\subsection{Conclusion}
\nocite{sts}
\nocite{atapl}
\printbibliography{}

\end{document}